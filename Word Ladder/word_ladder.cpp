#include "assignments/wl/word_ladder.h"

/*
   * Takes in an std::string as input, finds all words that have a single letter different from it
   * and stores all such words in a vector and puts it in the map with the input as the key
   * It is called over and over again in FindLadder so that we can generate the whole working
   * word space (i.e. all words that are one letter different from each other so that we
   * may find a path to the destination
   * */

void GetWordCombinations(const Lexicon &word_list,
                         const std::string &source,
                         Dictionary &word_map,
                         std::deque<std::string> &helper_queue)
{
    std::vector<std::string> differences;
    std::string copy = source;
    for (std::string::size_type i = 0; i < source.size(); ++i)
    {
        for (int j = 0; j < 26; ++j)
        {
            copy[i] = static_cast<char>('a' + j);
            auto find = word_list.find(copy);
            if (find != word_list.end() && source != copy)
            {
                differences.emplace_back(copy);
                helper_queue.emplace_back(copy);
            }
        }
        copy = source;
    }

    word_map[source] = differences;
}

/*
   * The main working function which calls all the other utility functions to find the answer
   * 1) Calls FindLadder to get the working word list
   * 2) Calls BreadthFirstFind to get the "level" of the destination (if present)
   * 3) Calls DepthFirstFind to get the shortest paths to the destination,
   *    if BreadthFirstFind returns a solution
   * 4) Sorts the paths array returned by DepthFirstFind and returns it to main
   * */
std::vector<std::vector<std::string>>
FindLadder(const Lexicon &word_list, const std::string &source, const std::string &destination)
{
    Dictionary word_map = {};
    std::vector<std::vector<std::string>> all_paths;
    std::vector<std::string> found_words;
    std::deque<std::string> helper_queue;
    found_words.emplace_back(source);
    /*
     * This is a particularly nifty piece of code, and the first time I found an actual use
     * for do-while. Of course, it could have been done with a while(true), but still.
     *
     * The vector inside calls the GetWordCombinations function on each of its elements, which are
     * words found in the previous iteration of GetWordCombinations. Now since you cannot modify an
     * STL container while using it because that would be unsafe and only someone ridiculously stupid
     * would ever even try it (totally not me). The helper-queue "holds" the value of the current
     * iteration words, and then once the vector is done, supplies it to the vector and resets itself
     * so that GetWordCombinations may be called on all the words.
     *
     * I did not do a grand job of explaining it, I admit
     * */
    do
    {
        helper_queue.clear();
        for (const auto &word : found_words)
            if (word_map.find(word) == word_map.end())
                GetWordCombinations(word_list, word, word_map, helper_queue);
        found_words.clear();
        std::copy(helper_queue.begin(), helper_queue.end(), std::back_inserter(found_words));
    } while ((!helper_queue.empty()));

    std::unordered_map<std::string, int> depth = BreadthFirstFind(word_map, source, destination);
    if (depth.find(destination) == depth.end())
    {
        return all_paths;
    }
    std::vector<std::string> current_path;
    DepthFirstFind(source, destination, word_map, depth, all_paths, current_path);
    std::sort(all_paths.begin(), all_paths.end());
    return all_paths;
}

/*
   * Takes in the word map generated by GetWordCombinations, and does a breadth first search
   * to find which "level" the destination is on, if present. Level is basically
   * the depth of the word ladder "tree", so that depth first search can find the shortest paths
   * to it. Returns a map with the depth of each word in the word_map upto the destination.
   * Source is at 0, and all words one letter different to it are at depth 1,
   * two letters different are at depth 2, and so on. Optimises the search space
   * */
std::unordered_map<std::string, int> BreadthFirstFind(const Dictionary &word_map,
                                                      const std::string &source,
                                                      const std::string &destination)
{
    std::unordered_map<std::string, int> depth;
    depth[source] = 0;
    std::deque<std::string> bfs_queue;
    bfs_queue.emplace_front(source);
    while (!bfs_queue.empty())
    {
        if (std::find(bfs_queue.begin(), bfs_queue.end(), destination) != bfs_queue.end())
        {
            return depth;
        }
        auto popped = bfs_queue.at(0);
        bfs_queue.pop_front();
        auto list = word_map.find(popped);
        if (list == word_map.end())
            continue;
        for (const auto &word : list->second)
        {
            if (depth.find(word) == depth.end())
            {
                depth[word] = depth[popped] + 1;
                bfs_queue.emplace_back(word);
            }
        }
    }

    return depth;
}

/*
   * Uses recursive Depth First Search to find the shortest paths based on depth
   * calculated in BreadthFirstFind.
   * */
void DepthFirstFind(const std::string &source,
                    const std::string &destination,
                    const Dictionary &word_map,
                    const std::unordered_map<std::string, int> &depth,
                    std::vector<std::vector<std::string>> &all_paths,
                    std::vector<std::string> current_path)
{
    current_path.emplace_back(source);
    if (source == destination)
    {
        all_paths.emplace_back(current_path);
        return;
    }
    else
    {
        auto list = word_map.find(source);
        if (list == word_map.end())
            return;

        for (const auto &word : list->second)
        {
            if (depth.find(word) != depth.end() &&
                depth.find(word)->second == depth.find(source)->second + 1)
            {
                DepthFirstFind(word, destination, word_map, depth, all_paths, current_path);
            }
        }
    }
}
